"""
There's two solution to this problem, 
  - Recursion with prune, techincally still O(k^n)
  - Bitmask binary Recursion, O(2^n)

We can get the target sum of each subset by doing sum(nums) / k, so we can get this information before hand.
(Recursion with prune)
Idea: 
Try to place the current number in nums to a bucket, if the sum in the bucket > the target, we skip this bucket and try to place in the next bucket.
- If All the number are placed, "if idx == len(nums)", check the sum of each bucket to ensure it is indeed equals to the targetSum, If all of it is correct, return True.
- If a number can't be place in any bucket -> return Fals.
- After a number is placed in a bucket, recursive call the function and try to place the next number.
- Since the current placing may lead to wrong path, we backtrack and try another path if this path cant continue ( a number can't be place in any bucket )
- Therefore, we backtracking by subtract the placed number from the bucket, indicate that number is free again, and try to place other numbers.

"""




class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        target = total // k
        if total % k != 0:
            return False
        nums.sort(reverse = True)
        bucket_map = [0 for i in range(k)]
        def backtrack(idx):
            if idx == len(nums):
                for sums in bucket_map:
                    if sums != target:
                        return False
                return True
            for i in range(k):
                if bucket_map[i] + nums[idx] > target:
                    continue
                if i > 0 and bucket_map[i] == bucket_map[i-1]:
                    continue
                bucket_map[i] += nums[idx]
                if backtrack(idx + 1):
                    return True
                bucket_map[i] -= nums[idx]

            return False
        
        return backtrack(0)
